表示游戏的规则
a)执行方式描述了游戏的时间发展的方式，游戏时间的滚动，是游戏世界所有元素产生变化的唯一动力。
b)游戏世界的时间每滚动(tick)一次，游戏内的物体可以获得一次更新自己的机会。否则整个世界处于静止状态


说明：
1、timeRuler负责生成时间片，并把时间片信息从输出管道送出.
    a)时间片生成的频度，主要和游戏世界的数据需要更新的实时程度(用户关心的响应速度)有关
    b)一次时间片内，可能会处理游戏外部用户的多次输入，所以对时间片的频率控制是十分重要的
    c)当一次时间片内积累过多的外部输入的时候，这些输入之间可能会存在重复输入，比如后续的操作会覆盖前面的，那么这里可以做一些优化，
        比如对消息队列进行分组，同一类互斥的操作只保留最后一次的（比如指令MOVE(from,to),多次执行完全没有必要，可以直接执行最后一次的
        因为服务端认为，在本次时间片开始之前，用户是完全静止的）
2、时间片交给一个外部的agent(可能是一个region的god)
3、如果需要在多个region(可能是跨机器的)之间同步时间，这个无需region担心，通过timeRuler之间的交互和同步来实现。
4、timeRuler的设计主要在于隔离region对时间控制的感知，至于何时考虑timeRuler对服务器的全局时间同步，以后再实现。


备注：
1、之前想到，如果没有timeRuler,在region内部做time.Sleep也可以达到同样的效果，但是，从灵活性角度，这样的设计无疑更好。
    比如我就是想加快某个地图的处理速度(时间的流逝),包括内部npc的成长速度（BT的需求...)，只需要以某种外部方式，不停的给
    timeRuler施加触发脉冲即可