保存智能体相关定义。

智能体的定义：

类型：
1、玩家本身
2、npc玩家
3、野怪等

特质：
1、可以移动、攻击等
2、可以被生产和制造
3、可以两两之间直接通信，也可以通过regionManager间接通信

实现：

agent的主动行为和被动行为：

被动行为：
1、agent的数据必须由自己来更新，这就需要有一个goroutine轮询获取数据更新请求，来实时更新自身。数据更新的请求消息，
放在【in消息管道】里

主动行为：
1、agent要有主动行为，必须有一个goroutine去接收时间片，然后根据一些智能方法，去选择做一些事情

需要有【时间片管道】，因为要防止agent之间的死锁，比如(a攻击b,需要等待b更新完数据，b同时也在攻击a,这样就导致死锁)。
这样一个agent至少2个goroutine在跑，1个做被动的事情（比如更新自己状态),一个做主动的事情，确保不会死锁

2、在agent主动行为的过程中，有可能与其他agent发生交互，产生以下情况：
    a)需要通知对方去更新数据，对方更新完成没有，必须有一个回应
        比如A攻击B，扣B的hp
            方法1：A可以向B的【in消息管道】发送一个数据更新请求
                    然后监听B的【out消息管道】
                问题：如何确保out消息管道里的消息是给攻击者A的？
            方法2：建立【1对1通信通道】
                    请求与B建立直连通道，获得【B.inPipe】【B.outPipe】,同时B可获得【A.inPipe,A.outPipe】
                    A向【B.inPipe】中发送扣
                问题：
                    这样会建立n多pipe
                    agent之间互相修改状态，逻辑由agent决定了
            方法3：【A,B 不直接交互，通过regionManager进行交互操作】
                每个agent只需要和region交互
                agent交互逻辑在region处理
 综上：
 1、agent需要可以与其他对象通信，并且通信的时候使用一组专属的in,out通道
    【regionManager与agent通信也是一样，需要事先建立2个管道】
 2、agent需要一个独立的时间片管道，这个管道是单向的，告诉agent有新的时间片分配过来，这时候可以做主动操作
 3、每个agent至少要有2个goroutine：
    一个负责处理主动操作（轮询时间片通道）
    一个负责处理所有被动消息，并回复给对应的消息返回通道
        (2015-07-15 发现轮询一个动态的消息通道slice不好实现，所以暂时定义常量，
        然后代码写死switch+select分支)
        由于被动消息通道有了上限，agent需要另外一个消息通道，用于紧急的系统管理，比如强制给agent发一个指令
        这个通道也由goroutine管理

 update 2015-07-16：今天和go群里人沟通，得到了更好的设计思路：
    1、agent和外部agent通信，只有一个输入chan
    2、当外部agent需要和自己通信的时候，临时创建一个respChan,外部拿到这个chan(独享的),用于接收自己的回复
    3、agent只需要轮询一个输入chan就可以了，无须为每个对象创建独立的inChan
 update 2015-07-16下午：今天又遇到一个问题，最后得以解决，还是思路上想的过于复杂，导致了不必要的设计：
    问题：现在B,C同时和A通信，A有一个唯一的入口chan,（上午讨论的）
           B,C申请和A通信的时候，A会给B,C每人一个responseChan,这2个chan是独立的

           B,C拿到这个chan,就可以构造你说的Entity了

           现在问题是，A在轮询入口chan,得到消息的发送者，然后处理，然后给“发送者对应的responseChan”回复消息

           那么，可能有一天B,C不再需要和A通信了，是否需要以什么方式告知A

           就是这里的模式，一般怎么做比较简洁

           我的想法是，加一个消息类型，A拿到这个消息类型，就知道发送者要和自己断开了，就close他对应的responseChan
     解决：
        思路上，“应答chan”是由“请求发起者”提供的，而不是接受者提供的。
        在发出消息上，带上回复chan,消息接受者直接往这个chan回复
        一切问题都解决了
        现在使用3个goroutine，分别轮询消息、管理、时间片
 update 2015-07-18：
    今天和周继健聊了一下，其实对于简单的游戏服务，完全可以用一个线程来处理一个区域内所有的个体的逻辑，这样：
        1、就不用考虑区域内的数据更新和同步问题
        2、不需要建立成千上万个agent,区域的god就是一个agent,他处理区域内所有的消息
        3、当地图由多区域构成（比如网游），多个god也可以充分利用多核性能，不存在浪费问题

