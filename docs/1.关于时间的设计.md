#时间系统的设计原则

*1 允许game时间与现实生活时间速度不一致

*2 允许game中，不同模块的时间处理粒度不一致

#对原则的理解
> 对于1很好理解，比如我们可以让游戏1s跑10帧(100ms一帧)，然后每一帧代表游戏里的1s.这样下来，现实中的1s就相当于游戏里的10s
> 对于2是这样的，在有些游戏中，比如survive,在非作战情况下，游戏时间我可能希望比现实快10倍。但是作战的时候，我希望程序的每一次触发仍然和现实一样，这样有些逻辑处理就比较方便。

#实现的思考
> 游戏中，有时间管道的概念，管道有“时间输入”和“时间输出”。这2个值都有“单位”的概念
> 管道要确保，每次输出的时间片，都是【1个输出单位】
    > 所有的时间片来源，都从全局的时间发生器，以脉冲形式发出
    > 内部模块可以构建自己的时间管道，并且定义管道所接收的时间单位
        > 例子：
            > 某管道的输入单位是“10秒”，输出单位是“1秒”
                > 那么，如果该管道 下面对接了很多单位，那么当管道从外部接到一个单位的时间片，就向下级推送10个单位的时间片。那么下面这些单位会一次获取10个输出单位，从而进行逻辑处理（比如战斗hp回复）


#时间帧的应用、用户消息处理
> 用户的消息是实时处理的，并不需要等待时间帧的到来
> 时间帧是提供给游戏内部逻辑“主动”运行的驱动，而：
    > 用户交互消息可以看成是“用户”参与这个“运行着的世界”的过程
    > 用户的每个指令，都是对世界里某个单位的“未来动作”的定义，是可以实时处理的，可以看成是“不消耗时间”的，例如：
        > 装备一个东西
            > 这如果是非战斗状态，可以看成不耗时间
            > 如果是战斗状态，那装备武器这个动作如果设计为要消耗行动力，那么这个就需要等待角色自己进行
            > PS:当然，有一种统一的设计方法，用行动力来控制：
                > 在非战斗状态下，游戏1s等于现实10s,所以行动力可能恢复很快，所以玩家操作装备感觉一下完成了
                > 战斗状态下，游戏的
        > 攻击一个人（实际上的处理是：“设定攻击目标”，因为真正的“攻击”需要角色自己完成，而角色必须等待时间片到来）